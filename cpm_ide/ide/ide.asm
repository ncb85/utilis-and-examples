;IDE HDD driver for 8085 CPU, based on work of Paul Stoffregen
;The main handshaking signals between the drive and the host are the
;busy bit (BSY) and the data request bit (DRQ) (in the status register) and
;the interrupt (INTRQ) signal. They can be set in one of the following ways:
;Any reset will cause BSY to be set. Writing a command to the command register
;will also set BSY. The BSY bit is used to indicate that the controller is busy
;and should not be accessed.
;The DRQ bit is used to control the data transfer to and from the controller.
;The host can read/write the data register only when the DRQ bit is set to 1.
;The INTRQ signal is generated by the drive to interrupt the host.
;For example, during a Read Sector command, the drive generates an INTRQ to the host
;whenever a sector is ready for the host to read. No INTRQ is generated immediately
;after completion of a Read command. The number of interrupts equals the number
;of sectors read. During a Write Sector command, the drive generates an INTRQ when-
;ever the drive requests data from the host (except for the first sector).
;The drive also generates an interrupt immediately after completion of a
;Write command. The number of interrupts equals the number of sectorswritten.
;All commands that do not include read- or write-data transfers generate
;a single interrupt when the command completes. Resets do not generate an interrupt.
;INTRQ is cleared when the host reads the status register. The host can
;read the Alternate Status register without clearing the INTRQ
;
;Alternate Status register register contains the same information as the Status
;register in the command block. The only difference is that reading this register
;does not imply interrupt acknowledge or reset a pending interrupt. This register
;can be read at any time.
;
;Bit   7   6    5   4   3   2    1   0
;Name BSY DRDY DWF DSC DRQ CORR IDX ERR
;
                .module IDE_DRIVER
                .area   SMALLC_GENERATED  (REL,CON,CSEG)
                .list   (err, loc, bin, eqt, cyc, lin, src, lst, md)
                .nlist  (pag)
                .globl  ide_init, ide_hard_reset, ide_read_sector, ide_write_sector, ide_get_status
                .globl  ide_get_error, ide_spinup, ide_spindown, ide_drive_id, lba_flag, LBA, BUFFER
                ;
                ;internal ram usage
lba_flag:       .db  0                      ;0 - use CHS geometry, 0x40 (bit 6) use LBA28
LBA:            .db  0,0,0,0                ;4 bytes, 28 bit Logical Block Address
;stack           .equ  0x40  
BUFFER:         .ds  512                    ;a 512 byte buffer
                ;
                ;8255 chip address
IDE_8255_BASE   .equ  0x70                  ;8255 io address
IDE_8255_LSB    .equ  IDE_8255_BASE         ;port A - lower 8 bits
IDE_8255_MSB    .equ  IDE_8255_BASE+1       ;port B - upper 8 bits
IDE_8255_CTL    .equ  IDE_8255_BASE+2       ;port C - control lines
CFG_8255        .equ  IDE_8255_BASE+3       ;status/command register
RD_IDE_8255     .equ  0b10010010            ;IDE_8255_CTL out, IDE_8255_LSB/msb input
WR_IDE_8255     .equ  0b10000000            ;all three ports output
                ;
                ;IDE control lines for use with IDE interfaced to PIO8255
IDE_A0_LINE     .equ  0x01                  ;direct from 8255 to ide interface
IDE_A1_LINE     .equ  0x02                  ;direct from 8255 to ide interface
IDE_A2_LINE     .equ  0x04                  ;direct from 8255 to ide interface
IDE_CS0_LINE    .equ  0x08                  ;inverter between 8255 and ide interface
IDE_CS1_LINE    .equ  0x10                  ;inverter between 8255 and ide interface
IDE_WR_LINE     .equ  0x20                  ;inverter between 8255 and ide interface
IDE_RD_LINE     .equ  0x40                  ;inverter between 8255 and ide interface
IDE_RST_LINE    .equ  0x80                  ;inverter between 8255 and ide interface
;-----------------------------------------------------------------------
;IDE register addresses
;-----------------------------------------------------------------------
;Command Block registers - IDE_CS0_LINE
;0 0 0 Data register
;0 0 1 Error register/Feature register
;0 1 0 Sector Count register
;0 1 1 Sector Number register
;1 0 0 Cylinder Low register
;1 0 1 Cylinder High register
;1 1 0 Drive/Head register
;1 1 1 Status register/Command register
;-----------------------------------------------------------------------
;Control Block registers - IDE_CS1_LINE
;1 1 0 Alternate Status register/Device Control register
;1 1 1 Drive Address register/Not used
;-----------------------------------------------------------------------
IDE_DATA        .equ  IDE_CS0_LINE  
IDE_ERR         .equ  IDE_CS0_LINE + IDE_A0_LINE
IDE_SEC_CNT     .equ  IDE_CS0_LINE + IDE_A1_LINE
IDE_SECTOR      .equ  IDE_CS0_LINE + IDE_A1_LINE + IDE_A0_LINE
IDE_CYL_LSB     .equ  IDE_CS0_LINE + IDE_A2_LINE
IDE_CYL_MSB     .equ  IDE_CS0_LINE + IDE_A2_LINE + IDE_A0_LINE
IDE_DRIVE_HEAD  .equ  IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE
IDE_COMMAND     .equ  IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
IDE_STATUS      .equ  IDE_CS0_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
IDE_CONTROL     .equ  IDE_CS1_LINE + IDE_A2_LINE + IDE_A1_LINE
IDE_ASTATUS     .equ  IDE_CS1_LINE + IDE_A2_LINE + IDE_A1_LINE + IDE_A0_LINE
;IDE Command Constants.  These should never change.
IDE_CMD_RECAL   .equ  0x10
IDE_CMD_READ    .equ  0x20
IDE_CMD_WRITE   .equ  0x30
IDE_CMD_INIT    .equ  0x91
IDE_CMD_ID      .equ  0xEC
IDE_CMD_SPINDOWN .equ 0xE0
IDE_CMD_SPINUP  .equ  0xE1
;IDE Status Register:
;BSY is the busy bit. It is set to 1 whenever the drive has access to the
;command block. When it is set to 1:
; No other bits are valid.
; The host is locked out of reading shared registers, the Status register is read instead.
;The BSY bit is set to 1 under the following circumstances:
; At the assertion of the RESET– signal on the interface
; At the assertion of the SRST bit in the Device Control register
; Immediately upon host write to the Command register
;DRDY is the drive ready indicator bit. This bit is set to 0 at power up and
;remains set at 0 until the drive is ready to accept a command.
;DWF is the drive write fault bit. When there is a write fault error, this
;bit is set to 1 and is not changed until the Status register is read
;by the host, at which time the bit again indicates the current write fault status.
;DSC is the drive seek complete bit. It is set to 1 when the disc drive is not seeking.
;DRQ is the data request bit. It is set to 1 when the drive is ready to transfer a word
;or byte of data between the host and the data port. The drive is busy whenever
;DRQ or BSY bits are set to 1. When the DRQ bit is set to 1, the host may read or write
;any of the registers including the Command register.
;CORR is the corrected data bit. It is set to 1 when a correctable data
;error has been encountered and the data has been corrected.
;This condition does not end a multisector read operation. This
;bit is set to 0 when a new command is serviced.
;IDX is the index bit. This bit usually contains a 0, except once per
;disc revolution when it is toggled from 0 to 1 and back to 0.
;ERR is the error bit. It is set to 1 when the previous command ended
;in some type of error. The other bits in the Status register, and
;the bits in the Error register, have more information as to the
;cause of the error.
STATUS_BSY      .equ 0x80                   ;1=busy, 0=not busy
STATUS_DRDY     .equ 0x40                   ;drive ready, 1=ready for command, 0=not ready yet
STATUS_DWF      .equ 0x20                   ;drive write fault bit
STATUS_DSC      .equ 0x10                   ;drive seek complete bit
STATUS_DRQ      .equ 0x08                   ;data request bit, 1=ready to transfer data
STATUS_CORR     .equ 0x04                   ;corrected data bit
STATUS_IDX      .equ 0x02                   ;index bit
STATUS_ERR      .equ 0x01                   ;error occured
                ;
                ; wait aprox. 80us (42t fixed + 24t x LOOP)
                ; 5MHz CPU 400 cycles (act.402)
                ; 8MHz CPU 640 cycles
udelay:         push b                      ;[12]
                lxi b,15                    ;[10]  const CRYSTAL/2
dela1:          dcx b                       ;[6]
                mov a,b                     ;[4]
                ora c                       ;[4]
                jnz dela1                   ;[10]
                pop b                       ;[10]
                ret                         ;[10]
                ;
                ;do a hard reset on the drive, by pulsing its reset pin.
                ;this should usually be followed with a call to "ide_init".
ide_hard_reset: mvi a,RD_IDE_8255           ;config 8255 chip, read mode
                out CFG_8255                ;write to config register
                mvi a,IDE_RST_LINE          ;reset pin
                out IDE_8255_CTL            ;hard reset the disk drive
                mvi c,0                     ;loop interval
rst_dly:        call udelay                 ;delay (reset pulse width)
                dcr c                       ;decrement
                jnz rst_dly                 ;wait more
                xra a                       ;clear A
                out IDE_8255_CTL            ;no ide control lines asserted
                ret
                ;
                ;Get status, return value in both A and L
ide_get_status: mvi a,IDE_STATUS            ;status register address to acc
                call ide_rd_8               ;read status reg, wait for BSY bit to be cleared
                mov a,l                     ;move to acc
                ret
                ;
                ;Get error, return value in both A and L
ide_get_error:  mvi a,IDE_ERR               ;status register address to acc
                call ide_rd_8               ;read status reg, wait for BSY bit to be cleared
                mov a,l                     ;move to acc
                ret
                ;
                ;Wait for the drive to become not busy
                ;Returns the drive's status in Acc
ide_wait_not_busy:
                call ide_get_status         ;read status reg
                ;should probably check for a timeout here
                ani STATUS_BSY              ;busy bit cleared?
                jnz ide_wait_not_busy       ;no, wait for BSY to be cleared
                mov a,l                     ;status to acc
                ret
                ;
                ;Wait for the drive to become not busy
                ;Returns the drive's status in Acc TODO use ide_wait_not_busy
ide_wait_ready: call ide_get_status         ;read status reg
                ;should probably check for a timeout here
                ani STATUS_DRDY             ;ready bit set?
                jz ide_wait_ready           ;no, wait for DRDY to be set
                mov a,l                     ;status to acc
                ret
                ;
                ;Wait for the drive to be ready to transfer data.
                ;Returns the drive's status in Acc
                ;sets carry on timeout
ide_wait_drq:   push d                      ;back up DE
                lxi d,0                     ;timeout/tries 65536
idwdrl:         call ide_get_status         ;read status reg
                dcx d                       ;decrement DE
                mov a,d                     ;is it zero?
                ora e                       ;set flags
                jz err_time                 ;yes DRQ bit was not set in time
                mov a,l                     ;status to acc
                ani STATUS_DRQ              ;drq bit set?
                jz idwdrl                   ;no, wait for DRQ to be set
                mov a,l                     ;status to acc
                pop d                       ;restore DE
                ret                         ;
err_time:       stc                         ;set carry
                pop d                       ;restore DE
                ret
                ;
        	;initialize the ide drive
ide_init:       mvi a,IDE_DRIVE_HEAD        ;Drive/Head register address
                mvi l,0xA0                  ;A0 - master drive, B0 - slave drive
                call ide_wr_8               ;select the master device
                call ide_wait_ready         ;wait for IDE to become ready
                ; uncomment this section if you have a very old hard drive
                ; (probably win3.1 or early win95 era) that does not even
                ; allow LBA accesses until these CHS parameters are set up
                ;mvi     a, IDE_DRIVE_HEAD
                ;mvi     l, 0xAF             ;master
                ;call    ide_wr_8            ;what should this config parm be?
                ;mvi     a, IDE_SEC_CNT
                ;mvi     l, 64
                ;call    ide_wr_8            ;what should this config parm be?
                ;mvi     a, IDE_COMMAND
                ;mvi     l, IDE_CMD_INIT
                ;call    ide_wr_8            ;do init parameters command
                ;call    ide_wait_not_busy
                ret
                ;
        	;tell the drive to spin up
ide_spinup:     mvi l,IDE_CMD_SPINUP        ;spin up command
spup2:          mvi a,IDE_COMMAND           ;command register address into acc
                call ide_wr_8               ;write to drive
                call ide_wait_not_busy      ;wait for completion
                ret
                ;
        	;tell the drive to spin down
ide_spindown:   call ide_wait_not_busy      ;wait till drive not busy
                mvi l,IDE_CMD_SPINDOWN      ;spin down command
                jmp spup2                   ;execute it
                ;
                ;write a sector, specified by the 4 bytes in "lba",
                ;whatever is in the buffer gets written to the drive!
                ;Return, acc is zero on success, non-zero for an error
ide_write_sector: call ide_wait_not_busy    ;make sure drive is ready
                call wr_lba                 ;tell it which sector we want
                mvi a,IDE_COMMAND           ;command register address to acc
                mvi l,IDE_CMD_WRITE         ;write command
                call ide_wr_8               ;tell drive to write a sector
                call ide_wait_drq           ;wait unit it wants the data
                ani STATUS_ERR              ;error bit set?
                jnz get_err                 ;yes handle it
                lxi d,BUFFER                ;set source buffer address
                call write_data             ;give the data to the drive
                call ide_wait_not_busy      ;wait until the write is complete
                ani STATUS_ERR              ;error bit set?
                jnz get_err                 ;yes handle it
                xra a                       ;clear acc
                lxi h,0                     ;return no error to C
                ret
                ;
                ;Write a block of 512 bytes (DE register address) to the drive
                ;input D = lsb source data address
                ;input E = msb source data address
                ;BC is changed
write_data:     mvi b,0                     ;counter 256x2=512 bytes
wrblk2:         ldax d                      ;load higher byte from adress at DE
                mov h,a                     ;move to H
                inx d                       ;increment DE
                ldax d                      ;load lower byte
                mov l,a                     ;move to L
                inx d                       ;increment DE
                mvi a,IDE_DATA              ;data register address
                call ide_wr_16              ;do 16 bit write
                dcr b                       ;decrement byte counter
                jnz wrblk2                  ;write next two bytes
                ret
                ;
                ;when an error occurs, we get acc bit 0 set from a call to ide_drq
                ;or ide_wait_not_busy (which read the drive's status register).  If
                ;that error bit is set, we should jump here to read the drive's
                ;explaination of the error, to be returned to the user.  If for
                ;some reason the error code is zero (shouldn't happen), we'll
                ;return 255, so that the main program can always depend on a
                ;return of zero to indicate success.
get_err:        mvi a,IDE_ERR               ;error register address to acc
                call ide_rd_8               ;do 8bit read
                mov a,l                     ;move value to acc
                mvi h,0                     ;return value to C
                ora a                       ;set flags
                jz gerr2                    ;zero (shouldn't happen)
                ret                         ;
gerr2:          mvi l,255                   ;return 255 to C
                ret
                ;
                ;read a sector, specified by the 4 bytes in "lba",
                ;Return, acc is zero on success, non-zero for an error
ide_read_sector: call ide_wait_not_busy     ;make sure drive is ready
                call wr_lba                 ;tell it which sector we want
                mvi a,IDE_COMMAND           ;command register address to acc
                mvi l,IDE_CMD_READ          ;read command
                call ide_wr_8               ;ask the drive to read it
                call ide_wait_drq           ;wait until it's got the data
                ani STATUS_ERR              ;error bit set?
                jnz get_err                 ;yes handle it
                lxi d,BUFFER                ;destination RAM
                call read_data              ;grab the data
                xra a                       ;clear acc
                lxi h,0                     ;return no error to C
                ret
                ;
                ;do the identify drive command, and return with the buffer
                ;filled with info about the drive
ide_drive_id:   call ide_wait_not_busy      ;wait till drive not busy
                mvi a,IDE_DRIVE_HEAD        ;Drive/Head register address
                mvi l,0xA0                  ;A0 - master drive, B0 - slave drive
                call ide_wr_8               ;select the master device
                call ide_wait_ready         ;wait till drive ready
                mvi a,IDE_SEC_CNT           ;sector count
                mvi l,1                     ;one sector
                call ide_wr_8               ;values as specified by ATA
                mvi a,IDE_SECTOR            ;sector number
                mvi l,1                     ;sector 1
                call ide_wr_8               ;values as specified by ATA
                mvi a,IDE_CYL_LSB           ;cylinder number
                mvi l,1                     ;cylinder 1
                call ide_wr_8               ;values as specified by ATA
                mvi a,IDE_CYL_MSB           ;cylinder number higher byte
                mvi l,0                     ;cylinder 0
                call ide_wr_8               ;values as specified by ATA
                mvi a,IDE_COMMAND           ;command register address into acc
                mvi l,IDE_CMD_ID            ;identify command
                call ide_wr_8               ;issue the command
                call ide_wait_drq           ;ready for data transfer?
                lxi d,BUFFER                ;destination address
                call read_data              ;read data
                ret
                ;
                ;Read a block of 512 bytes (one sector) from the drive
                ;and store it in memory at DE register address
                ;input D = lsb destination address to write to
                ;input E = msb destination address to write to
                ;HL,C is changed
read_data:      mvi c,0                     ;counter 256x2=512 bytes
rdblk2:         mvi a,IDE_DATA              ;data register address
                call ide_rd_16              ;do 16 bit read
                mov a,h                     ;higher byte
                stax d                      ;store at DE
                inx d                       ;increment DE
                mov a,l                     ;lower byte
                stax d                      ;store at DE
                inx d                       ;increment DE
                dcr c                       ;decrement byte counter
                jnz rdblk2                  ;read next two bytes
                ret
                ;
                ;write the logical block address to the drive's registers
                ;28-bit unsigned binary number:
                ; bits 27–24 into the Drive/Head register bits 3–0
                ; bits 23–16 into the Cylinder High register
                ; bits 15–8 into the Cylinder Low register
                ; bits 7–0 into the Sector Number register
                ; In the Drive/Head register, bit 6 (LBA) is set to 0 for CHS addressing
                ; and set to 1 for logical block addressing
wr_lba:         lda LBA+3                   ;load acc from LBA+3, bits 31-24
                ani 0x0F                    ;mask out bits 31-28
                ori 0xA0                    ;A0 - master drive
                mov l,a                     ;back up to L
                lda lba_flag                ;bit 6(1=LBA)
                ora l                       ;add bit 6
                mov l,a                     ;move to param L
                mvi a,IDE_DRIVE_HEAD        ;Drive/Head register address
                call ide_wr_8               ;do 8 bit write
                lda LBA+2                   ;load acc from LBA+2, cylinder MSB, bits 23-16
                mov l,a                     ;move to param L
                mvi a,IDE_CYL_MSB           ;cylinder MSB register address
                call ide_wr_8               ;do 8 bit write
                lda LBA+1                   ;load acc from LBA+1, cylinder LSB, bits 15-8
                mov l,a                     ;move to param L
                mvi a,IDE_CYL_LSB           ;cylinder LSB register address
                call ide_wr_8               ;do 8 bit write
                lda LBA+0                   ;load acc from LBA+0, sector number, bits 7-0
                mov l,a                     ;move to param L
                mvi a,IDE_SECTOR            ;sector register address
                call ide_wr_8               ;do 8 bit write
                mvi a,IDE_SEC_CNT           ;sector count register address
                mvi l,1                     ;sector count=1
                call ide_wr_8               ;do 8 bit write
                ret
                ;
                ;------------------------------------------------------------------
                ; Low Level I/O to the drive.  These are the routines that talk
                ; directly to the drive, via the 8255 chip.  Normally a main
                ; program would not call to these.
                ;------------------------------------------------------------------
                ;Do a read bus cycle to the drive, using the 8255.
                ;input ACC = ide register address
                ;output L = lower byte read from ide drive
                ;output H = upper byte read from ide drive
ide_rd_16:
                out IDE_8255_CTL            ;drive address onto control lines
                ori IDE_RD_LINE             ;assert read pin
                out IDE_8255_CTL            ;
                in IDE_8255_MSB             ;read the upper byte
                mov h,a                     ;back up to H
                in IDE_8255_LSB             ;read the lower byte
                mov l,a                     ;back up to L
                xra a                       ;clear A
                out IDE_8255_CTL            ;deassert all control pins
                ret
                ;
ide_rd_8:       out IDE_8255_CTL            ;drive address onto control lines
                ori IDE_RD_LINE             ;assert read pin
                out IDE_8255_CTL            ;
                in IDE_8255_LSB             ;read the lower byte
                mov l,a                     ;back up to L
                xra a                       ;clear A
                out IDE_8255_CTL            ;deassert all control pins
                ret
                ;
                ;Do a write bus cycle to the drive, via the 8255
                ;input ACC = ide register address
                ;input L = lsb to write
                ;input H = msb to write
                ;C is changed
ide_wr_16:      mov c,a                     ;back up address in C
                mvi a,WR_IDE_8255           ;config 8255 chip, write mode
                out CFG_8255                ;
                mov a,l                     ;get lsb
                out IDE_8255_LSB            ;drive lower lines with lsb
                mov a,h                     ;get msb
                out IDE_8255_MSB            ;drive upper lines with msb
                mov a,c                     ;restore address
                out IDE_8255_CTL            ;drive address onto control lines
                ori IDE_WR_LINE             ;assert write pin
                out IDE_8255_CTL            ;drive address onto control lines
                mov a,c                     ;deassert write pin, restore address
                out IDE_8255_CTL            ;drive address onto control lines
                mvi a, RD_IDE_8255          ;config 8255 chip, read mode
                out CFG_8255                ;
                ret
                ;
ide_wr_8:       mov c,a                     ;back up address in C
                mvi a,WR_IDE_8255           ;config 8255 chip, write mode
                out CFG_8255                ;
                mov a,l                     ;get lsb
                out IDE_8255_LSB            ;drive lower lines with lsb
                mov a,c                     ;restore address
                out IDE_8255_CTL            ;drive address onto control lines
                ori IDE_WR_LINE             ;assert write pin
                out IDE_8255_CTL            ;drive address onto control lines
                mov a,c                     ;deassert write pin, restore address
                out IDE_8255_CTL            ;drive address onto control lines
                mvi a,RD_IDE_8255           ;config 8255 chip, read mode
                out CFG_8255                ;
                ret
                ;
                .end